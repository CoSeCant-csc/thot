/*
thot package for statistical machine translation
Copyright (C) 2017 Adam Harasimowicz, Daniel Ortiz-Mart\'inez

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License
as published by the Free Software Foundation; either version 3
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************/
/*                                                                  */
/* Module: StlPhraseTable                                           */
/*                                                                  */
/* Definitions file: StlPhraseTable.cc                              */
/*                                                                  */
/********************************************************************/


//--------------- Include files --------------------------------------

#include "StlPhraseTable.h"

//--------------- Function definitions

//-------------------------
StlPhraseTable::StlPhraseTable(void)
{
}

//-------------------------
StlPhraseTable::SrcTrgKey StlPhraseTable::getSrcTrgKey(const std::vector<WordIndex>& s,
                                                       const std::vector<WordIndex>& t,
                                                       bool &found)
{
    SrcPhraseInfo::iterator srcIter = srcPhraseInfo.find(s);
    TrgPhraseInfo::iterator trgIter = trgPhraseInfo.find(t);

    // Add missing information to obtain iterator for t phrase
    if (trgIter == trgPhraseInfo.end())
    {
        addTrgInfo(t, 0);
        trgIter = trgPhraseInfo.find(t);
    }

    // Check if s exists in collections
    found = !(srcIter == srcPhraseInfo.end());

    return SrcTrgKey(srcIter, trgIter);
}

//-------------------------
bool StlPhraseTable::getNbestForSrc(const std::vector<WordIndex>& s,
                                 NbestTableNode<PhraseTransTableNodeData>& nbt)
{
    // Not implemented
}
//-------------------------
bool StlPhraseTable::getNbestForTrg(const std::vector<WordIndex>& t,
                                    NbestTableNode<PhraseTransTableNodeData>& nbt,
                                    int N)
{
    StlPhraseTable::SrcTableNode::iterator iter;
    
    bool found;
    Count t_count;
    StlPhraseTable::SrcTableNode node;
    LgProb lgProb;
    
    // Make sure that collection does not contain any old elements
    nbt.clear();

    found = getEntriesForTarget(t, node);
    t_count = cTrg(t);

    if(found) {
        // Generate transTableNode
        for(iter = node.begin(); iter != node.end(); iter++)
        {
            std::vector<WordIndex> s = iter->first;
            PhrasePairInfo ppi = (PhrasePairInfo) iter->second;
            float c_st = (float) ppi.second.get_c_st();
            lgProb = log(c_st / (float) t_count);
            nbt.insert(lgProb, s); // Insert pair <log probability, source phrase>
        }

#   ifdef DO_STABLE_SORT_ON_NBEST_TABLE
        // Performs stable sort on n-best table, this is done to ensure
        // that the n-best lists generated by cache models and
        // conventional models are identical. However this process is
        // time consuming and must be avoided if possible
        nbt.stableSort();
#   endif

        while(nbt.size() > (unsigned int) N && N >= 0)
        {
            // node contains N inverse translations, remove last element
            nbt.removeLastElement();
        }

        return true;
    }
    else
    {
        // Cannot find the target phrase
        return false;
    }
}

//-------------------------
void StlPhraseTable::addTableEntry(const std::vector<WordIndex>& s,
                                   const std::vector<WordIndex>& t,
                                   PhrasePairInfo inf)
{
    addSrcInfo(s, inf.first.get_c_s());  // src
    addTrgInfo(t, inf.second.get_c_s());  // trg
    addSrcTrgInfo(s, t, inf.second.get_c_st());  // (src, trg)
}

//-------------------------
void StlPhraseTable::addSrcInfo(const std::vector<WordIndex>& s,
                                Count s_inf)
{
    SrcPhraseInfo::iterator iter = srcPhraseInfo.find(s);

    if (iter == srcPhraseInfo.end())  // Check if s exists in collection
    {
        srcPhraseInfo.insert(make_pair(s, s_inf));
    }
    else
    {
        iter->second = s_inf;
    }
}

//-------------------------
void StlPhraseTable::addTrgInfo(const std::vector<WordIndex>& t,
                                Count t_inf)
{
    TrgPhraseInfo::iterator iter = trgPhraseInfo.find(t);

    if (iter == trgPhraseInfo.end())  // Check if t exists in collection
    {
        trgPhraseInfo.insert(make_pair(t, t_inf));
    }
    else
    {
        iter->second = t_inf;
    }
}

//-------------------------
void StlPhraseTable::addSrcTrgInfo(const std::vector<WordIndex>& s,
                                   const std::vector<WordIndex>& t,
                                   Count st_inf)
{
    bool found;
    SrcTrgKey srcTrgKey = getSrcTrgKey(s, t, found);

    if (!found)
    {
        std::cerr << "Unexpected behaviour: (s, t) key parts cannot be found" << std::endl;
        std::cerr << "Make sure that entries for s phrase and t phrase are added before adding (s, t) entry" << std::endl;
        exit(1);
    }

    // Update entry value
    SrcTrgPhraseInfo::iterator iter = srcTrgPhraseInfo.find(srcTrgKey);

    if (iter == srcTrgPhraseInfo.end())  // Check if (s, t) exists in collection
    {
        srcTrgPhraseInfo.insert(make_pair(srcTrgKey, st_inf));
    }
    else
    {
        iter->second = st_inf;
    }
}

//-------------------------
void StlPhraseTable::incrCountsOfEntry(const std::vector<WordIndex>& s,
                                       const std::vector<WordIndex>& t,
                                       Count c)
{
    // Retrieve previous states
    Count s_count = cSrc(s);
    Count t_count = cTrg(t);
    Count src_trg_count = cSrcTrg(s, t);

    // Update counts
    addSrcInfo(s, s_count + c);  // src
    addTrgInfo(t, t_count + c);  // trg
    addSrcTrgInfo(s, t, (src_trg_count + c).get_c_st());  // (src, trg)
}

//-------------------------
PhrasePairInfo StlPhraseTable::infSrcTrg(const std::vector<WordIndex>& s,
                                         const std::vector<WordIndex>& t,
                                         bool& found)
{
    PhrasePairInfo ppi;

    ppi.first = getSrcInfo(s, found);
    if(!found)
    {
        ppi.second = 0;
        return ppi;
    }
    else
    {
        ppi.second = getSrcTrgInfo(s, t, found);
        return ppi;
    }
}

//-------------------------
Count StlPhraseTable::getSrcInfo(const std::vector<WordIndex>& s,
                                 bool &found)
{
    SrcPhraseInfo::iterator iter = srcPhraseInfo.find(s);

    if (iter == srcPhraseInfo.end())  // Check if s exists in collection
    {
        found = false;
        return 0;
    }
    else
    {
        found = true;
        return iter->second;
    }
}

//-------------------------
Count StlPhraseTable::getTrgInfo(const std::vector<WordIndex>& t,
                                 bool &found)
{
    TrgPhraseInfo::iterator iter = trgPhraseInfo.find(t);

    if (iter == trgPhraseInfo.end())  // Check if t exists in collection
    {
        found = false;
        return 0;
    }
    else
    {
        found = true;
        return iter->second;
    }
}

//-------------------------
Count StlPhraseTable::getSrcTrgInfo(const std::vector<WordIndex>& s,
                                    const std::vector<WordIndex>& t,
                                    bool &found)
{
    SrcTrgKey srcTrgKey = getSrcTrgKey(s, t, found);
    if (!found) return 0;

    SrcTrgPhraseInfo::iterator srcTrgIter = srcTrgPhraseInfo.find(srcTrgKey);

    // Check if entry for (s, t) pair exists
    if (srcTrgIter == srcTrgPhraseInfo.end())
    {
        found = false;
        return 0;
    }
    else
    {
        found = true;
        return srcTrgIter->second;
    }
}

//-------------------------
Prob StlPhraseTable::pTrgGivenSrc(const std::vector<WordIndex>& s,
                                  const std::vector<WordIndex>& t)
{
    // p(s|t) = count(s,t) / count(t)
    Count st_count = cSrcTrg(s, t);
    if ((float) st_count > 0)
    {
        Count t_count = cTrg(t);
        if ((float) t_count > 0)
            return ((float) st_count) / ((float) t_count);
        else
            return PHRASE_PROB_SMOOTH;
    }
    else return PHRASE_PROB_SMOOTH;
}

//-------------------------
LgProb StlPhraseTable::logpTrgGivenSrc(const std::vector<WordIndex>& s,
                                       const std::vector<WordIndex>& t)
{
    return log((double) pTrgGivenSrc(s, t));
}

//-------------------------
Prob StlPhraseTable::pSrcGivenTrg(const std::vector<WordIndex>& s,
                                  const std::vector<WordIndex>& t)
{
    Count count_s_t_ = cSrcTrg(s, t);
    if((float) count_s_t_ > 0)
    {
        Count count_t_ = cTrg(t);
	    if((float) count_t_ > 0)
        {
            return (float) count_s_t_ / (float) count_t_;
        }
	    else return PHRASE_PROB_SMOOTH;
    }
    else return PHRASE_PROB_SMOOTH;
}

//-------------------------
LgProb StlPhraseTable::logpSrcGivenTrg(const std::vector<WordIndex>& s,
                                       const std::vector<WordIndex>& t)
{
    return log((double) pSrcGivenTrg(s, t));
}

//-------------------------
bool StlPhraseTable::getEntriesForTarget(const std::vector<WordIndex>& t,
                                         StlPhraseTable::SrcTableNode& srctn)
{
    bool found;
    srctn.clear();  // Make sure that structure does not keep old values

    // Prepare iterators
    SrcTrgKey srcTrgBegin = getSrcTrgKey(srcPhraseInfo.begin()->first, t, found);
    if (!found) return false;

    SrcTrgKey srcTrgEnd = getSrcTrgKey(srcPhraseInfo.end()->first, t, found);  // Maybe use rbegin
    if (!found) return false;

    // Define border elements for searched source phrases
    SrcTrgPhraseInfo::iterator srcTrgIterBegin = srcTrgPhraseInfo.lower_bound(srcTrgBegin);
    SrcTrgPhraseInfo::iterator srcTrgIterEnd = srcTrgPhraseInfo.upper_bound(srcTrgEnd);

    for (SrcTrgPhraseInfo::iterator srcTrgIter = srcTrgIterBegin; srcTrgIter != srcTrgIterEnd; srcTrgIter++)
    {
        SrcPhraseInfo::iterator srcIter = srcTrgIter->first.first;  // First element of the pair of iterators (s, t)
        std::vector<WordIndex> s = srcIter->first;
        PhrasePairInfo ppi;
        ppi.first = srcIter->second;  // s count
        ppi.second = srcTrgIter->second;  // (s, t) count

        if ((int) ppi.first.get_c_s() == 0 || (int) ppi.second.get_c_s() == 0)
            continue;

        srctn.insert(pair<std::vector<WordIndex>, PhrasePairInfo>(s, ppi));
    }

    return srctn.size();
}

//-------------------------
bool StlPhraseTable::getEntriesForSource(const std::vector<WordIndex>& s,
                                      StlPhraseTable::TrgTableNode& trgtn)
{
    // Not implemented
}

//-------------------------
Count StlPhraseTable::cSrcTrg(const std::vector<WordIndex>& s,
                              const std::vector<WordIndex>& t)
{
    bool found;
    return getSrcTrgInfo(s, t, found).get_c_st();
}

//-------------------------
Count StlPhraseTable::cSrc(const std::vector<WordIndex>& s)
{
    bool found;
    return getSrcInfo(s, found).get_c_s();
}

//-------------------------
Count StlPhraseTable::cTrg(const std::vector<WordIndex>& t)
{
    bool found;
    return getTrgInfo(t, found).get_c_st();
}

//-------------------------
size_t StlPhraseTable::size(void)
{
    size_t srcSize = srcPhraseInfo.size();
    size_t trgSize = trgPhraseInfo.size();
    size_t srcTrgSize = srcTrgPhraseInfo.size();

    return srcSize + trgSize + srcTrgSize;
}
//-------------------------
void StlPhraseTable::clear(void)
{
    srcPhraseInfo.clear();
    trgPhraseInfo.clear();
    srcTrgPhraseInfo.clear();
}

//-------------------------
StlPhraseTable::~StlPhraseTable(void)
{
}

//-------------------------
StlPhraseTable::const_iterator StlPhraseTable::begin(void)const
{
    // TODO
//   StlPhraseTable::const_iterator iter(this,phraseDict.begin());
//   return iter;
}
//-------------------------
StlPhraseTable::const_iterator StlPhraseTable::end(void)const
{
    // TODO
//   StlPhraseTable::const_iterator iter(this,phraseDict.end());
//   return iter;
}

// const_iterator function definitions
//--------------------------
bool StlPhraseTable::const_iterator::operator++(void) //prefix
{
    // TODO
//   if(ptPtr!=NULL)
//   {
//     ++pdIter;
//     if(pdIter==ptPtr->phraseDict.end()) return false;
//     else
//     {
//       return true;
//     }
//   }
//   else return false;
}
//--------------------------
bool StlPhraseTable::const_iterator::operator++(int)  //postfix
{
    // TODO
//   return operator++();
}
//--------------------------
int StlPhraseTable::const_iterator::operator==(const const_iterator& right)
{
    // TODO
//   return (ptPtr==right.ptPtr && pdIter==right.pdIter);
}
//--------------------------
int StlPhraseTable::const_iterator::operator!=(const const_iterator& right)
{
    // TODO
//   return !((*this)==right);
}

//--------------------------
StlPhraseTable::PhraseInfoElement StlPhraseTable::const_iterator::operator*(void)
{
    return *operator->();
}

//--------------------------
const StlPhraseTable::PhraseInfoElement*
StlPhraseTable::const_iterator::operator->(void)
{
   // TODO
//   return pdIter;
}

//-------------------------
